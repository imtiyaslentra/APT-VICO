)
    end
end)
-- Open Source Blade Ball Auto Parry By PawsThePaw --
--// My Discord: pawsthepaw
--// Notes: I'm not giving Away my Freeze & Invisibility Detection, lmao, this is sort of decent, time based, Enjoy, Skid, or Learn, Its Your Choice
local aura_table = {
        ["AutoParry"] = true,
        ["PingBased"] = true,
        ["PingBasedOffset"] = 0,
        ["DistanceToParry"] = 0.5,
        ["BallSpeedCheck"] = true,
        ["hit_Count"] = 0,
    	["hit_Time"] = tick(),
	    ["ball_Warping"] = tick(),
	    ["is_ball_Warping"] = false,
	    ["last_target"] = nil,
}

Vim = game:GetService ("VirtualInputManager")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer or Players.PlayerAdded:Wait()
local ReplicatedPaw = game:GetService("ReplicatedStorage")

local Paws = ReplicatedPaw:WaitForChild("Remotes", 9e9)
local PawsBalls = workspace:WaitForChild("Balls", 9e9)
local PawsTable = getgenv().Paws

local function IsTheTarget()
        return Player.Character:FindFirstChild("Highlight")
end

function getClosestEntityToMouse()
	local closest = nil
	local shortestDistance = math.huge
	local mouse = game.Players.LocalPlayer:GetMouse()

	-- Ensure workspace.Alive exists
	if not workspace:FindFirstChild("Alive") then
		return nil
	end

	-- Loop through all entities
	for _, entity in pairs(workspace.Alive:GetChildren()) do
		if entity:IsA("Model") then
			local humanoidRootPart = entity:FindFirstChild("HumanoidRootPart")
			if humanoidRootPart then
				-- Convert world position to screen position
				local screenPoint = camera:WorldToViewportPoint(humanoidRootPart.Position)
				local distanceToMouse = (Vector2.new(screenPoint.X, screenPoint.Y) - Vector2.new(mouse.X, mouse.Y)).Magnitude

				-- Check if this is the closest entity so far
				if distanceToMouse < shortestDistance then
					closest = entity
					shortestDistance = distanceToMouse
				end
			else
				
			end
		else
			
		end
	end

	-- If no closest entity is found, warn the user
	if not closest then
		
	else
		
	end

	return closest
end

local closest_Entity_To_mouse = nil
local Takentime = tick() - aura_table.hit_Time
RunService.Heartbeat:Connect(function()
Takentime = tick() - aura_table.hit_Time
	task.spawn(function()
		closest_Entity_To_mouse = getClosestEntityToMouse()
	end)
end)

local function FindBall()
    local RealBall
    for i, v in pairs(PawsBalls:GetChildren()) do
        if v:GetAttribute("realBall") == true then
            RealBall = v
        end
    end
    return RealBall
end

game:GetService("RunService").PreRender:connect(function()
        if not FindBall() then 
                return
        end
        local self = FindBall()
        
        local player_Position = local_player.Character.PrimaryPart.Position
    local ball_Position = self.Position
    local ball_Velocity = self.AssemblyLinearVelocity

local ball_Direction = (local_player.Character.PrimaryPart.Position - ball_Position).Unit
    local ball_Distance = (local_player.Character.PrimaryPart.Position - ball_Position).Magnitude
    local ball_Dot = ball_Direction:Dot(ball_Velocity.Unit)
    local ball_Speed = ball_Velocity.Magnitude

local player_Velocity = local_player.Character.HumanoidRootPart.AssemblyLinearVelocity
    local player_isMoving = player_Velocity.Magnitude > 0
    local ball_speed_Limited = math.min(ball_Speed / 1000, 0.1)
    local ball_predicted_Distance = (ball_Distance - ping / 15.3) - (ball_Speed / 3.5)

local targetPosition = closest_Entity_To_mouse.HumanoidRootPart.Position
    local target_Distance = local_player:DistanceFromCharacter(targetPosition)
    local closest_target_Distance = local_player:DistanceFromCharacter(closest_Entity.HumanoidRootPart.Position)
    local target_distance_Limited = math.min(target_Distance / 10000, 0.1)
    local target_Direction = (local_player.Character.PrimaryPart.Position - closest_Entity.HumanoidRootPart.Position).Unit
    local target_Velocity = closest_Entity.HumanoidRootPart.AssemblyLinearVelocity
    local target_isMoving = target_Velocity.Magnitude > 0
    local target_Dot = target_isMoving and math.max(target_Direction:Dot(target_Velocity.Unit), 0)

speedFactor = 3 - (ping / 100)
    speedFactorPingBased = 6.1 - (ping / 100)
    aura_table.parry_Range = math.max(math.max(ping, 3.5) + ball_Speed / speedFactor, speedFactorPingBased)

local velocity_angle = math.abs(math.acos(ball_Direction:Dot(ball_Velocity.Unit)))

    if ball_Dot < -0.2 then
        aura_table.ball_Warping = tick()
    end

    task.spawn(function()
        if (tick() - aura_table.ball_Warping) >= 0.15 + target_distance_Limited - ball_speed_Limited or ball_Distance <= 10 then
            aura_table.is_ball_Warping = false
            return
        end

        if aura_table.last_target then
            if (ball_Position - aura_table.last_target.HumanoidRootPart.Position).Magnitude > 35.5 or target_Distance <= 12 then
                aura_table.is_ball_Warping = false
            end
        end

        aura_table.is_ball_Warping = true
    end)
        
        local Ping = BallVelocity * (game.Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000)
        
        if PawsTable.PingBased then
        Distance -= Ping + PawsTable.PingBasedOffset
        end
        
        if PawsTable.BallSpeedCheck and BallVelocity == 0 then return
        end
        
        if (Distance / BallVelocity) <= PawsTable.DistanceToParry and IsTheTarget() and PawsTable.AutoParry then

Vim:SendMouseButtonEvent(0, 0, 0, true, game, 0)
           end
end)
